# Start with waterfall model

# About waterfall model

https://en.wikipedia.org/wiki/Waterfall_model

**Source**

Inspired by the "linear sequential" development process in construction and manufacturing, computer scientist Winston Royce introduced this linear sequential development process into the field of software engineering in 1970, forming the waterfall model.

**Definition**

The waterfall model divides the software development process into a series of strictly sequential stages, including requirements analysis, system design, program design, coding implementation, testing, and maintenance.
Each stage must be completed before it can begin, and there is no feedback or iteration between stages.

**Achievement**

It is an important milestone in the development of software engineering and has laid the foundation for subsequent software engineering theory and practice.
The shortcomings of the waterfall model have promoted the rise of agile methods and contributed to the evolution of software development methodology.

**Problem**

Difficult to respond to rapid changes in software requirements.

# Iterative and Incremental Development, IID

https://en.wikipedia.org/wiki/Iterative_and_incremental_development

Pre-**Agile**，Divide and conquer to quickly response changes of requirement.

# **Agile software development**

## **Agile manifesto**

**Source**

During the 1990s, a number of *lightweight* software development methods evolved in reaction to the prevailing *heavyweight* methods (often referred to collectively as [*waterfall*](https://en.wikipedia.org/wiki/Waterfall_model)) .

In 2001, The group, The Agile Alliance, published the *Manifesto for Agile Software Development*.

**Content of the agile manifesto**

The agile manifesto reads:

*We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:*

- ***Individuals and interactions** over processes and tools*
- ***Working software** over comprehensive documentation*
- ***Customer collaboration** over contract negotiation*
- ***Responding to change** over following a plan*

*That is, while there is value in the items on the right, we value the items on the left more.*

**Principles**

The values are based on these principles:

1. Customer satisfaction by early and continuous delivery of valuable software.
2. Welcome changing requirements, even in late development.
3. Deliver working software frequently (weeks rather than months).
4. Close, daily cooperation between business people and developers.
5. Projects are built around motivated individuals, who should be trusted.
6. Face-to-face conversation is the best form of communication (co-location).
7. Working software is the primary measure of progress.
8. Sustainable development, able to maintain a constant pace.
9. Continuous attention to technical excellence and good design.
10. Simplicity—the art of maximizing the amount of work not done—is essential.
11. Best [architectures](https://en.wikipedia.org/wiki/Agile_Architecture), requirements, and designs emerge from self-organizing teams.
12. Regularly, the team reflects on how to become more effective, and adjusts accordingly.

## Practices of Agile.

XP

TDD

DDD

FDD

https://en.wikipedia.org/wiki/Continuous_integration

https://en.wikipedia.org/wiki/Code_refactoring

Scrum

https://en.wikipedia.org/wiki/Kanban_(development)

## Common agile software development pitfalls

**Lack of overall product design**

A goal of agile software development is to focus more on producing working software and less on documentation. This is in contrast to waterfall models where the process is often highly controlled and minor changes to the system require significant revision of supporting documentation. However, this does not justify completely doing without any analysis or design at all. Failure to pay attention to design can cause a team to proceed rapidly at first, but then to require significant rework as they attempt to scale up the system. One of the key features of agile software development is that it is iterative. When done correctly, agile software development allows the design to emerge as the system is developed and helps the team discover commonalities and opportunities for re-use.

**Problem-solving in the daily standup**

A daily standup should be a focused, timely meeting where all team members disseminate information. If problem-solving occurs, it often can involve only certain team members and potentially is not the best use of the entire team's time. If during the daily standup the team starts diving into problem-solving, it should be set aside until a sub-team can discuss, usually immediately after the standup completes.

**Allowing technical debt to build up**

Focusing on delivering new functionality may result in increased [technical debt](https://en.wikipedia.org/wiki/Technical_debt). The team must allow themselves time for defect remediation and refactoring. Technical debt hinders planning abilities by increasing the amount of unscheduled work as production defects distract the team from further progress.

As the system evolves it is important to [refactor](https://en.wikipedia.org/wiki/Code_refactoring).

Over time the lack of constant maintenance causes increasing defects and development costs.

**Attempting to take on too much in an iteration**

A common misconception is that agile software development allows continuous change, however an iteration backlog is an agreement of what work can be completed during an iteration.[118] Having too much work-in-progress (WIP) results in inefficiencies such as context-switching and queueing.[119] The team must avoid feeling pressured into taking on additional work.[120]

**Developer burnout**

Due to the focused pace and continuous nature of agile practices, there is a heightened risk of burnout among members of the delivery team.[[122]](https://en.wikipedia.org/wiki/Agile_software_development#cite_note-122)

## To be better —— **Software craftsmanship**

https://en.wikipedia.org/wiki/Software_craftsmanship

https://manifesto.softwarecraftsmanship.org/

**Raising the bar.**

As aspiring Software Craftsmen we are raising the bar of professional software development by practicing it and helping others learn the craft. Through this work we have come to value:

Not only working software,

but also **well-crafted software**

Not only responding to change,

but also **steadily adding value**

Not only individuals and interactions,

but also **a community of professionals**

Not only customer collaboration,

but also **productive partnerships**

That is, in pursuit of the items on the left we have found the items on the right to be indispensable.